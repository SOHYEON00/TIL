# 호이스팅 Hoisting

<br/>

> 자바스크립트에서 아주 중요한 개념인 호이스팅을 이해해보자. <br/>
> 출처: 코어자바스크립트 (정재남)

<br/>

## 호이스팅 개념이 나온 이유

<br/>

호이스팅이란 변수 수집 과정을 이해하기 쉽게 만들기 위해 나온 가상의 개념이다.

자바스크립트 엔진의 핵심이라 할 수 있는 실행 컨텍스트를 공부하다보면, LexicalEnvironment와 VariableEnvironment에 저장되는 environmentRecord가 있다.<br/>이 때, environmentRecord에는 현재 컨텍스트와 관련된 코드의 ***식별자 정보***들이 순서대로 수집되어 저장된다.

    식별자 정보 : 주로 변수명을 가리키며, 여기서는 매개변수 이름, 함수선언문 전체, var로 선언된 변수명 등이 해당된다.

<br/>

이 때 중요한 것은 식별자 정보들이 현재 실행 컨텍스트와 관련된 코드들에 대해 **순서대로** 수집되어 저장된다는 것이다.  
순서대로가 중요한 이유는 잠시 후, 예제를 통해 살펴보자.

environmentRecord에 식별자 정보들이 수집되어 저장되었다는 의미는 실행 컨텍스트에 관여된 코드들도 실행되었다는 이야기가 절대 아니다. 그래서 "실제로 이해를 돕기 위해 위로 끌어올렸다." 는 의미의 hoist를 사용해 만들어진 개념이 호이스팅(hoisting)이다.

즉, 실제로 JS 엔진이 식별자들을 끌어올리는 것은 아니지만 편의상 나온 개념이라고 이해할 수 있다.
<br/> MDN에 첫 문단에 나오는 것처럼 잘못하면 JS엔진이 식별자(변수 및 함수 선언)가 작성한 코드의 상단으로 옮기는 걸로 오해할 수 있다. **절대 코드는 옮겨지지 않는다.** 호이스팅은 하나의 개념일 뿐이다.

<br/>

>다만, 아래의 예제들에서는 호이스팅 개념의 이해를 돕기 위해 코드를 변경하도록 하겠다. <br/>
>다시 말하지만, 절대 실제 코드가 옮겨지는 게 아니다.

<br/><br/><br/>

## 예제로 이해해보는 호이스팅

<br/>

### 01 매개변수명도 식별자이다.

<br/>

다음과 같은 01 - 1번의 출력값을 예상해보자.
<br/>

```
// 01 - 1
function a(x){
    console.log(x);
    let x;
    console.log(x);
    let x =2;
    console.log(x);
  }
  
  a(1);
  ```

  그렇다면 다음의 코드의 출력값은 어떠할까?
  <br/>
  
  ```
// 01 - 2
function a(){
    let x;
    let x;
    let x;

    x = 1;
    console.log(x);
    console.log(x);
    x = 2;
    console.log(x);
  }
  
  a();
  ```

  <br/><br/>

두 개의 코드는 사실 같은 출력값을 가진다.  
'01-1'번의 코드를 호이스팅 개념을 돕기 위해 임의로 변경했을 때의 결과가 '01-2'번이라 이해하면 쉽다.  

#### 이해방법

그렇다면 어떻게 '01-1'을 '01-2'번으로 생각할 수 있을까?  

  * 매개변수명도 식별자이다. 즉, a(x)에 있는 x도 변수로서 선언되었음을 이해해야 한다.  
    그래서 function a()의 첫 문장이 console.log(x); 인 것 같지만 실제로는 매개변수를 선언하고 값을 할당해주는 코드가 먼저 실행되어야 한다.  
    
      > let x = 1; 이 먼저 실행된다.
  
  * 그 다음에 필요한 것이 호이스팅 개념이다.  
  분명 JS 엔진은 실행 컨텍스트와 관련된 코드를 실행하기 전에, 실행 컨텍스트의 환경 정보를 먼저 수집하고 저장한다고 했다. JS 엔진은 코드의 실행보다 먼저 식별자 정보를 수집한다.  
  그래서 '01-2'번에서는 어색할 수 있는 변수 x 선언문이 연달아 3개가 있게 되는 것이다.  
  이 때, 순서대로 수집됨을 잊지 말고 또, 남은 x의 할당은 그 자리에 그대로 남음을 기억하자.

<br/>
<br/>

#### 기억해야할 점

여기서 기억해야할 점이 몇 가지 있다.  

  - 중복된 식별자 선언문은 첫 선언문 외에 무시된다.
    그리하여, '01-2'번 a()의 let x;하나만 적용되는 건 바로 알 수 있다.
  
  - 매개변수는 함수 내부의 다른 코드들보다 **먼저** 선언과 할당이 이뤄진다. 
    그래서 첫 let x;는 기존의 매개변수 x의 선언이고 x=1;은 함수 a가 실행될 때 1을 인자로 가지고 있었기 때문에 매개변수의 할당문이다.

<br/><br/>

### 02 호이스팅에서의 함수

<br/>

호이스팅에서 함수는 살짝 다르게 이해해야 한다.  
바로 예제를 보자. 출력값을 예상해보자.

```
// 02-1
function a() {
  console.log(b);
  var b = 'bbb';
  console.log(b);
  function b() {};
  console.log(b);
}
a();
```
<br/>

```
// 02-2
function a() {
  var b;
  function b() {}; // var b = function() {}
  
  console.log(b);
  b = 'bbb';
  console.log(b);
  console.log(b);
}
a();
```
<br/>

예상했겠지만 '02-1'과 '02-2'는 같은 결과값을 가진다.  
여기서 주목할 점은 왜 첫번째 출력문이 undefined가 아니라 함수b를 출력하는가? 이다.  

#### 이해방법

함수 선언문은 식별자임과 동시에 할당문이다.  그래서 함수 선언은 함수명만 수집되는게 아니라 **함수 전체가 수집된다.**  
그래서 function b() {};을 조금 더 이해하기 쉽게 풀어보면 var b = function() {} 이것으로 이해할 수 있다.

 > 함수 선언문과 함수 표현식의 가장 큰 차이점은 호이스팅에 있다.  
  이는 다음에 더 자세히 해보도록 하겠지만 간단히 설명하자면, 함수 선언문은 함수 전체가 호이스팅되고 함수 표현식은 마치 변수명처럼 함수명만 호이스팅된다.

함수b는 호이스팅으로 올라온 선언부 같지만, 이미 선언된 변수 b가 있으므로 함수 b를 b에 할당한 것으로 이해하면 된다.  
그래서 첫 출력문이 undefined가 아니라 함수b를 출력한다.

<br/><br/>

이렇게 쉽고도 어려운 개념인 호이스팅을 정리해보았다.  
확실히 혼자 정리하는 것도 의미가 있지만 글을 쓰며 다시 정리하고, 설명하기 위해 이해해야하는 시간이 또 필요해서 글로 정리하는 건 이해에 효과적인 것 같다.

**호이스팅은 하나의 개념!**
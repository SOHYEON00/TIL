@@ -1,108 +0,0 @@
# React Hook


## Hook을 사용하는 이유

: 리액트를 클래스형 컴포넌트가 아니라 함수형 컴포넌트로 사용하기 위한 목적으로 생김.
즉, 함수형 컴포넌트를 만들고 싶은데 이전 리액트로는 상태관리, 생명주기 관리가 불가능했음. 단지 props를 받아서 출력하는 컴포넌트의 역할만 함. 이를 훅으로 보완함 (이전에는 class형 컴포넌트 - 컨트롤러, 함수형 컴포넌트 - 유닛)

- 컴포넌트에서 상태 관련 로직을 추상화할 수 있다.
-> 독립적인 테스트, 컴포넌트 재사용이 가능하다

    즉, 계층의 변화없이 상태 관련 로직을 재사용할 수 있게 해준다. -> hook 공유

- 당연히 컴포넌트들을 유지.보수해야하는데, 이 때 기존에 사용하던 셍명주기 메소드에는 자주 관련없는 로직이 들어가곤 한다.



## useMemo

- 메모아이제이션된 값을 반환함.

    memoization: 컴퓨터가 동일한 계산을 반복해야할 때, 이전에 계산된 값을 메모리에 저장하여 동일 계산의 반복 수행을 없애는 기술

- Syntax

    const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);

    - [a,b] : 의존성 배열. 해당 값이 변하는 경우에만 computeExpensiveValue(a, b) 가 다시 연산된다.
- 특징
    - useMemo로 전달된 함수는 렌더링 중에만 실행된다.
    - 의존성 배열이 없다면 매 렌더링마다 계산한다.
    - 이후 리액트는 useMemo의 사용이 무색하게 메모리에 기억하지 않고, 잊어버리고 다음 렌더링에 새로 계산하는 식으로 구현할지도 모름.
    -> useMemo를 사용하지 않고 구현한 이후, 최적화 시에만 사용하는 걸 추천함.
    - 연산되는 함수 안에서 참조되는 모든 값은 의존성 배열에 존재해야함.

useState

```
const [state, setState] = useState(initialState);

```

- 최초의 렌더링에는 state는 initialState의 값과 같다.
- initialState는 초기 렌더링에만 초기화를 위해 사용되는 값으로 그 이후의 값은 무시된다.
- setState 함수는 state 갱신할 때 사용함. (setState는 함수이다!!)
갱신하면 컴포넌트 리렌더링이 발생한다. (컴포넌트 리렌더링 큐에 새 state 값을 받아 등록함)
- setState를 useCallback, useEffect 디펜던시 배열에 넣지 않아도 되는 이유

    리액트 자체가 setState 함수 동일성이 안정적이고 리렌더링 시에도 변하지 않으리라고 보장하기 때문이다.

## useEffect

useEffect를 사용하는 이유

- 일반적으로 함수 컴포넌트 안에서 변형, 구독, 로깅, 타이머 처럼 사이드 이펙이 발생가능한 함수들은 사용 불가능하다. (이유: 버그 및 ui 불일치가 야기됨.)
이를 컴포넌트 안에서 안전하게 사용하기 위해 useEffect를 사용한다.

    Q. 변형, 구독, 로깅의 함수란??
    Q. 얘네들이 발생시킬 사이드 이펙트 종류

    Q. useEffect가 어떻게 안전하게 만들어주는지
    A. useEffect안의 함수는 렌더링 이후, 즉 레이아웃 배치와 그리기 이후에 실행된다.
    이는 이벤트 핸들러, 구독과 같은 함수들이 렌더링 도중 실행되면 그리기와 함수 실행이 거의 동시에 발생함에 따라 사이드 이펙이 발생할 수 있는데, useEffect는 렌더링 이후 실행되기 때문에 그럴 일이 없게 한다.

### useEffect의 실행 순서

- useEffect 안의 함수는 모든 렌더링이 완료된 이후 실행된다.
기본적으로는 이렇지만 의존성 배열을 통해 어떤 값이 변경되었을 때만 useEffect 안의 함수를 실행시킬 수 있다.

Q. 이때의 모든 렌더링이란 ??
A. 레이아웃 배치와 그리기

- useEffect는 브라우저 화면이 다 그려진 이후에 실행되며 다음에 발생할 새로운 렌더링 이전에 실행되는 것도 보장된다.

### useEffect의 역할

1. 정리

컴포넌트가 화면에서 제거될 때, 끊어져야하는 연결 등을 정리하는 역할을 할 수 있다. ex) subscribe, timer
이 역할은 정리하는 함수를 리턴함으로써 수행한다.

```

useEffect(() => {
   const subscription = props.source.subscribe();
   return () => {
   	subscription.unsubscribe();
   }
})

```

일반적으로 정리 함수는 메모리 누수 방지를 위해 ui가 화면에서 지워지기 전에 수행된다. 해당 예시는 사실, 매 갱신마다 새로운 구독이 발생하고 취소되는 현상이 발생한다.

## useLayoutEffect가 생긴 이유

useEffect는 렌더링 이후에 실행되기 때문에 사용자가 화면의 재렌더링을 경험하지 않도록 화면을 다 그리기 전에 값들을 동기화시켜야 할 때 사용한다.
=== 사용자에게 노출되는 DOM 변경은 사용자가 노출된 내용의 불일치를 경험하지 않도록 다음 화면을 다 그리기 이전에 동기화 되어야 합니다.

1. 의존성 배열

역할 : effect 함수가 무엇인지 표현하는 방법의 일

가져야하는 값 : useEffect 함수 안에서 참조되는 모든 값

[]의 의미 : 해당 useEffect를 한 번만 수행하고 싶은 경우. 이는 리액트에게 어떤 props, state 값에도 의존하지 않기 때문에 해당 useEffect를 다시 실행할 필요가 없다고 알려준다. 빈 배열을 전달하면 해당 useEffect 안의 props, state는 항상 초기값이다.

- 브라우저가 모두 그려질 때까지 리액트는 useEffect 수행을 미루기 때문에 다른 작업 때문에 useEffect의 수행에 문제가 생기지 않는다.
No newline at end of file
